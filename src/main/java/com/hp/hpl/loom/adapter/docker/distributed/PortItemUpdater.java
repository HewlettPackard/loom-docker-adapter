/*******************************************************************************
 * (c) Copyright 2017 Hewlett Packard Enterprise Development LP Licensed under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except in compliance with the License. You
 * may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *******************************************************************************/
package com.hp.hpl.loom.adapter.docker.distributed;

import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import com.hp.hpl.loom.adapter.AggregationUpdater;
import com.hp.hpl.loom.adapter.BaseAdapter;
import com.hp.hpl.loom.adapter.ConnectedItem;
import com.hp.hpl.loom.adapter.docker.distributed.realworld.HostManager;
import com.hp.hpl.loom.adapter.docker.items.PortItem;
import com.hp.hpl.loom.adapter.docker.items.PortItemAttributes;
import com.hp.hpl.loom.adapter.docker.items.Types;
import com.hp.hpl.loom.adapter.docker.realworld.ContainerPort;
import com.hp.hpl.loom.exceptions.NoSuchItemTypeException;
import com.hp.hpl.loom.exceptions.NoSuchProviderException;
import com.hp.hpl.loom.model.Aggregation;
import com.hp.hpl.loom.model.CoreItemAttributes.ChangeStatus;

/***
 * Collects all Container Ports, from all hosts
 */
public class PortItemUpdater extends AggregationUpdater<PortItem, PortItemAttributes, ContainerPort> {

    private static final String PORT_DESCRIPTION = "Represents a container or host open port";

    protected DockerDistributedCollector dockerCollector = null;

    /**
     * Constructs a PortItemUpdater.
     *
     * @param aggregation The aggregation this update will update
     * @param adapter The baseAdapter this updater is part of
     * @param DockerDistributedCollector The collector it uses
     *
     * @throws NoSuchItemTypeException Thrown if the ItemType isn't found
     * @throws NoSuchProviderException thrown if adapter is not known
     */
    public PortItemUpdater(final Aggregation aggregation, final BaseAdapter adapter,
            final DockerDistributedCollector dockerCollector) throws NoSuchItemTypeException, NoSuchProviderException {
        super(aggregation, adapter, dockerCollector);
        this.dockerCollector = dockerCollector;
    }

    /**
     * Each observed resource should have a way to be identified uniquely within the given adapter’s
     * domain and this is what should be returned here. This method is called to create the Item
     * logicalId.
     *
     * @return a unique way to identify a given resource (within the docker adapter). In the case of
     *         port, it is a hash generated by the combination of: containerId, containerPortNumber,
     *         portProtocol, hostID, hostPortNumber, hostInterfaceIp
     */
    @Override
    protected String getItemId(final ContainerPort argPort) {
        return Integer.toString(argPort.hashCode());
    }

    /***
     * This must return a brand new Iterator every collection cycle giving access to all the
     * resources that AggregationUpdater is observing.
     *
     */
    @Override
    protected Iterator<ContainerPort> getResourceIterator() {
        List<ContainerPort> portList = HostManager.getInstance(adapter).getAllPorts();

        return portList.iterator();
    }

    @Override
    protected Iterator<ContainerPort> getUserResourceIterator(final Collection<ContainerPort> data) {
        return data.iterator();
    }

    /**
     * This method should return an Item only set with its logicalId and ItemType.
     */
    @Override
    protected PortItem createEmptyItem(final String logicalId) {
        PortItem item = new PortItem(logicalId, itemType);
        return item;
    }

    /**
     * This should return a newly created CoreItemAttributes object based on data observed from the
     * resource.
     */
    @Override
    protected PortItemAttributes createItemAttributes(final ContainerPort resource) {

        PortItemAttributes attr = new PortItemAttributes();

        attr.setContainerID(resource.getContainerID());
        attr.setContainerPortNumber(resource.getContainerPortNumber());

        attr.setHostUID(resource.getHostID());
        attr.setHostPortNumber(resource.getHostPortNumber());
        attr.setInterfaceAddress(resource.getHostInterfaceIp());

        attr.setItemId(getItemId(resource));
        attr.setItemDescription(PORT_DESCRIPTION);
        attr.setItemName(attr.getContainerPortNumber() + "/" + attr.getPortProtocol());

        return attr;
    }

    /***
     * This method returns a status value encoded as follows:
     *
     * <p>
     * <strong>CoreItemAttributes.Status.UNCHANGED</strong>:there are no changes detected between
     * the previous view (the CoreItemsAttributes argument) and the new one (the Resource argument).
     * The selection of the attributes actually compared is left entirely at the adapter writer’s
     * discretion: for instance, our AggregationUpdater for an OpenStack volume checks the value of
     * the "status" attribute only.
     * <p>
     * <strong>CoreItemAttributes.Status.CHANGED_IGNORE</strong>: some attributes have changed but
     * those changes do not impact any queries or relationships, i.e. the current aggregation cache
     * that Loom has built is still valid. This is in particular targeted at the update of
     * metrics-like attributes or any fast changing ones.
     * <p>
     * <strong>CoreItemAttributes.Status.CHANGED_UPDATE</strong>: the attributes that have changed
     * have an impact of queries, derived attributes or relationships. This means that Loom should
     * mark the related GroundedAggregation as dirty and invalidate any cached DerivedAggregations
     *
     * @param PortAttributes The Port Item Attributes
     * @param resource the ContainerPort, as modelled on
     *        {@link com.hp.hpl.loom.adapter.docker.distributed.realworld} package
     * @return
     */
    @Override
    protected ChangeStatus compareItemAttributesToResource(final PortItemAttributes volumeAttributes,
            final ContainerPort resource) {

        ChangeStatus status;

        if (!volumeAttributes.getItemId().equals(Integer.toString(resource.hashCode()))) {
            status = ChangeStatus.CHANGED_UPDATE;
        } else {
            status = ChangeStatus.CHANGED_IGNORE;
        }

        return status;
    }

    /***
     * If the given resource is connected to another resource, then this method must set the itemId
     * of the connected Resource for a given relationship using the method
     * adapterItem.setRelationship(ItemTypeLocalId, connectedItemId) where ItemTypeLocalId is used
     * by the helper classes to name the relationship and derive the logicalId of the Item matching
     * the connected resource. ConnectedItem is an interface implemented by AdapterItem exposing the
     * few methods that should be used within the context of this method. *
     *
     * @param portItem the port item that Items will be connected to
     * @param resource the ContainerPort, as modelled on
     *        {@link com.hp.hpl.loom.adapter.docker.distributed.realworld} package
     */
    @Override
    @SuppressWarnings("checkstyle:linelength")
    protected void setRelationships(final ConnectedItem portItem, final ContainerPort resource) {

        // The container that contains that port
        portItem.setRelationshipWithType(adapter.getProvider(), Types.CONTAINER_TYPE_ID, resource.getContainerID(),
                "exposes");

        if (resource.getHostID() != ContainerPort.NO_INFORMATION) {
            portItem.setRelationshipWithType(adapter.getProvider(), Types.HOST_TYPE_ID, resource.getHostID(), "maps");
        }
    }
}
